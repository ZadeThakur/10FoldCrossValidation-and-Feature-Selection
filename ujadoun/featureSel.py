import numpy as np
import matplotlib.pyplot as plt
import mrmr

#Perform 10-fold cross-validation for each sub-feature set from
#the ranked list of features by MRMR. m is the training matrix
#in which the first row is the class label, and the others are
#features, and the columns are objects. Return the list
#of errors for the sub-feature sets.

def crossVal10(m):
    size = np.size(m, axis=1) #objects count
    fsize = size//10   #size of each fold
    er = 0
    s = mrmr.select(m) #list of indices for features selected by MRMR.
         #insert class label index as the first element
    X=m[1:]
    Y=m[0]

    foldsOfX=np.array_split(X,fsize+1,axis=1)
    foldsOfY=np.array_split(Y,fsize+1)

    errs = []
    #list of CV errors for sub-feature sets
    for i in range(len(s)):
        err=0
        for j in range(len(foldsOfX)):
            if i!=len(s)-1:
                X=foldsOfX[j][np.array(s[:i+1])-1]
            else:
                X=foldsOfX[j][np.array(s[:])-1]
            newX=np.vstack((foldsOfY[j],X))
            output=NB(newX,X)
            for d in range(len(output)):
                if (output[d]!=foldsOfY[j][d]):
                    err+=1
        errs.append(err)
    return errs

#m and r are the training and test matrixes in which the rows are features
#and columns are objects. This function classifies each object in matrix r
#using NB, which is built on matrix m. It returns the list of labels in which
#the ith label is assigned to the ith column in r.
def NB(m,r):
    s = set(m[0])
    ls = []
    for i in range(np.size(r, axis=1)):
        mxp = 0
        for a in s:
            b = np.nonzero(m[0] == a)
            m1 = (m[1:,b[0]] == np.reshape(r[:,i],(np.size(r,axis=0),1)))
            q = len(b[0])/len(m[0])
            for j in range(np.size(m1, axis=0)):
                q *= np.count_nonzero(m1[j])/len(b[0])
            if q > mxp:
                mxp = q
                c = a
        ls.append(c)
    return ls

#plot y against x as a connected line segment, as well as blue dots.
def plotit(x, y):
    plt.plot(x, y)
    plt.plot(x, y, 'bo')
    plt.xlabel('feature set size')
    plt.ylabel('CV error')
    plt.show()
                           
#find best k from 1 to num 
def main():
    m = np.loadtxt('train.txt', dtype=int)
    errors = crossVal10(m)
    minerr = min(errors)
    ind = errors.index(minerr)
    print('List of features generated by MRMR is',mrmr.select(m))
    print('List of errors in increasing sub-feature set sizes is', errors)
    print('Size of optimal feature set is',ind+1,'with CV error',minerr)
    plotit(['1','2','3','4','5'],errors)

main()


        
